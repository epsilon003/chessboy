{"ast":null,"code":"// Chess FEN/PGN parsing utilities\n\nexport const parseFEN = fen => {\n  const rows = fen.split('/');\n  const board = [];\n  rows.forEach(row => {\n    const boardRow = [];\n    for (let char of row) {\n      if (isNaN(char)) {\n        boardRow.push(char);\n      } else {\n        for (let i = 0; i < parseInt(char); i++) {\n          boardRow.push(null);\n        }\n      }\n    }\n    board.push(boardRow);\n  });\n  return board;\n};\nexport const boardToFEN = board => {\n  const rows = board.map(row => {\n    let fen = '';\n    let emptyCount = 0;\n    row.forEach(piece => {\n      if (piece === null) {\n        emptyCount++;\n      } else {\n        if (emptyCount > 0) {\n          fen += emptyCount;\n          emptyCount = 0;\n        }\n        fen += piece;\n      }\n    });\n    if (emptyCount > 0) {\n      fen += emptyCount;\n    }\n    return fen;\n  });\n  return rows.join('/');\n};\nexport const isValidFEN = fen => {\n  const parts = fen.trim().split('/');\n  if (parts.length !== 8) {\n    return false;\n  }\n  for (let part of parts) {\n    let count = 0;\n    for (let char of part) {\n      if (isNaN(char)) {\n        if (!'rnbqkpRNBQKP'.includes(char)) {\n          return false;\n        }\n        count++;\n      } else {\n        count += parseInt(char);\n      }\n    }\n    if (count !== 8) {\n      return false;\n    }\n  }\n  return true;\n};\nexport const analyzePosition = async fen => {\n  // Simulate analysis - in production, call Stockfish API\n  return new Promise(resolve => {\n    setTimeout(() => {\n      const analysis = {\n        evaluation: '+0.5',\n        bestMove: 'e2-e4',\n        topMoves: [{\n          move: 'e2-e4',\n          eval: '+0.5',\n          pv: 'e2-e4 e7-e5 Nf3 Nc6'\n        }, {\n          move: 'd2-d4',\n          eval: '+0.3',\n          pv: 'd2-d4 d7-d5 c4 e6'\n        }, {\n          move: 'Nf3',\n          eval: '+0.2',\n          pv: 'Nf3 Nf6 c4 e6'\n        }]\n      };\n      resolve(analysis);\n    }, 2000);\n  });\n};\nexport const parsePGN = pgn => {\n  // Simplified PGN parsing - in production use chess.js\n  console.log('PGN parsing requires chess.js library');\n  return 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\n};\nexport const STARTING_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';","map":{"version":3,"names":["parseFEN","fen","rows","split","board","forEach","row","boardRow","char","isNaN","push","i","parseInt","boardToFEN","map","emptyCount","piece","join","isValidFEN","parts","trim","length","part","count","includes","analyzePosition","Promise","resolve","setTimeout","analysis","evaluation","bestMove","topMoves","move","eval","pv","parsePGN","pgn","console","log","STARTING_FEN"],"sources":["C:/Users/student.DESKTOP-JJDV8M5/Desktop/my-app/frontend/src/utils/chess.js"],"sourcesContent":["// Chess FEN/PGN parsing utilities\r\n\r\nexport const parseFEN = (fen) => {\r\n  const rows = fen.split('/');\r\n  const board = [];\r\n  \r\n  rows.forEach(row => {\r\n    const boardRow = [];\r\n    for (let char of row) {\r\n      if (isNaN(char)) {\r\n        boardRow.push(char);\r\n      } else {\r\n        for (let i = 0; i < parseInt(char); i++) {\r\n          boardRow.push(null);\r\n        }\r\n      }\r\n    }\r\n    board.push(boardRow);\r\n  });\r\n  \r\n  return board;\r\n};\r\n\r\nexport const boardToFEN = (board) => {\r\n  const rows = board.map(row => {\r\n    let fen = '';\r\n    let emptyCount = 0;\r\n    \r\n    row.forEach(piece => {\r\n      if (piece === null) {\r\n        emptyCount++;\r\n      } else {\r\n        if (emptyCount > 0) {\r\n          fen += emptyCount;\r\n          emptyCount = 0;\r\n        }\r\n        fen += piece;\r\n      }\r\n    });\r\n    \r\n    if (emptyCount > 0) {\r\n      fen += emptyCount;\r\n    }\r\n    \r\n    return fen;\r\n  });\r\n  \r\n  return rows.join('/');\r\n};\r\n\r\nexport const isValidFEN = (fen) => {\r\n  const parts = fen.trim().split('/');\r\n  if (parts.length !== 8) {\r\n    return false;\r\n  }\r\n\r\n  for (let part of parts) {\r\n    let count = 0;\r\n    for (let char of part) {\r\n      if (isNaN(char)) {\r\n        if (!'rnbqkpRNBQKP'.includes(char)) {\r\n          return false;\r\n        }\r\n        count++;\r\n      } else {\r\n        count += parseInt(char);\r\n      }\r\n    }\r\n    if (count !== 8) {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  return true;\r\n};\r\n\r\nexport const analyzePosition = async (fen) => {\r\n  // Simulate analysis - in production, call Stockfish API\r\n  return new Promise((resolve) => {\r\n    setTimeout(() => {\r\n      const analysis = {\r\n        evaluation: '+0.5',\r\n        bestMove: 'e2-e4',\r\n        topMoves: [\r\n          { move: 'e2-e4', eval: '+0.5', pv: 'e2-e4 e7-e5 Nf3 Nc6' },\r\n          { move: 'd2-d4', eval: '+0.3', pv: 'd2-d4 d7-d5 c4 e6' },\r\n          { move: 'Nf3', eval: '+0.2', pv: 'Nf3 Nf6 c4 e6' }\r\n        ]\r\n      };\r\n      resolve(analysis);\r\n    }, 2000);\r\n  });\r\n};\r\n\r\nexport const parsePGN = (pgn) => {\r\n  // Simplified PGN parsing - in production use chess.js\r\n  console.log('PGN parsing requires chess.js library');\r\n  return 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\r\n};\r\n\r\nexport const STARTING_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}